<!DOCTYPE html>
<meta charset='utf-8'>
<style>

body {
	margin: 0 auto;
	padding: 1em;
	max-width: 1300px;
}

form {
	border: outset 1px #ccc;
	padding: .5em;
	display: grid;
	grid-template-columns: 30% 70%;
	grid-template-rows: repeat(2, [row] auto);
	grid-template-areas:
		'stats stats'
		'weapons info'
		'tips tips';
}

form label { margin: .2em; display: inline-block; }
form input { height: 1.5em; border: 1px #ccc inset; margin: .2em; padding: .1em; }
form input:invalid { background: #fee; }

form .stats { grid-area: stats; }
form .stats input { width: 3.5em; }

form .weapons {
	grid-area: weapons;
	display: grid;
	grid-template-rows: 3em minmax(20em, auto);
	grid-template-areas:
		'search'
		'list';
}
form .weapons .search { grid-area: search; }
form .weapons .list { width: 100%; grid-area: list; height: auto; resize: vertical; }

form .info { border-collapse: collapse; border-style: hidden; }
form .info th, form .info td { height: 1.5em; border: 1px dotted #ccc; padding: .2em .5em; }
form .info th { cursor: pointer; }

form .info th:hover { background: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.30) 100%); }
form .info tbody tr:hover { background: linear-gradient(to bottom, rgba(0,0,0,0) 0%,rgba(0,0,0,0.10) 100%); }
form .info tbody tr:nth-child(odd) { background-color: #eee; }

form .tips { grid-area: tips; }
</style>
<body>

<script src='d3.v5.min.js'></script>
<script>

let main, d3, data

let d3js_url = 'https://d3js.org/d3.v5.min.js',
	data_url = 'piratez-melee-calc.json'

let d3js_loaded = new Promise((resolve, reject) => {
		if (window.d3) return resolve(window.d3)
		let include = (url) => {
			let req = new XMLHttpRequest()
			req.open('GET', url)
			req.onreadystatechange = d => {
				if (req.status != 200 || req.readyState != 4) return
				eval(req.responseText)
				resolve(window.d3) }
			req.send() }
		console.log(`WARNING: loading d3 from ${d3js_url}`)
		include(d3js_url) })

window.onload = () => d3js_loaded
	.then(d3_local => { d3 = d3_local; return d3.json(data_url) })
	.then(json => { data = json; main() })

main = () => {

if (!d3) {
	document.body.innerHTML = `
		<h2>ERROR: failed to load d3.js library</h2>
		<p>Check uMatrix/NoScript/adblocker setttings or download
			<a href='${d3js_url}'>d3.v4.min.js</a> into same dir as this html.</p>`
	return
}

if (!data) {
	document.body.innerHTML = `
		<h2>ERROR: failed to load item data json</h2>
		<p>Check uMatrix/NoScript/adblocker setttings or put json file into same dir as this html.</p>`
	return
}


// Helpers

let
	// Usage: s.call(attrs(vals))
	attrs = vals => s => Object.entries(vals).forEach(([k,v]) => s.attr(k, v)),
	// Usage: s.call(fire_event('input'))
	fire_event = ev => s => s.each((d, n, ns) => s.on(ev)(d, n, ns)),
	// Usage: obj_compare([1,2,30], [1,2,4], d3.ascending) => 1
	obj_compare = (a1, a2, cmp) => {
		if (!((Array.isArray(a1) && Array.isArray(a2)) ||
				(a1 && a2 && typeof a1 === 'object' && typeof a2 === 'object')))
			return cmp(a1, a2)
		let keys = [], n
		if (Array.isArray(a1))
			for (n=0; n<Math.max(a1.length, a2.length); n++) keys.push(n)
		else {
			keys = Object.assign(Object.assign({}, a1), a2)
			keys = Object.keys(keys).sort(cmp) }
		for (n of keys) { n = cmp(a1[n], a2[n]); if (n !== 0) return n; } },
	// Usage: s.sort(sort_by_func(d3.ascending, d => d.fields[key]))
	sort_by_func = (cmp, func) => (a, b) => obj_compare(func(a), func(b), cmp),
	// Usage: s.data(map_entries(es6_map)) // Array of {key: ..., value: ...} like d3.entries()
	map_entries = map => Array.from(map.entries(map)).map(d => ({key: d[0], value: d[1]})),
	// Usage: obj_tuples(['asd', 'dfgdgf'], d => [d, d.length])
	obj_tuples = (arr, func) => arr.reduce((o, v) => { let k; [k, v] = func(v); o[k] = v; return o }, {}),
	// Usage: o2 = obj_clone(o)
	obj_clone = o => Object.assign({}, o),
	// Usage: value = obj_pop(o, key); obj_pop(o, key, value => ...)
	obj_pop = (o, key) => { let v = o[key]; delete o[key]; return v },
	obj_pop_run = (o, key, func) => { let v = o[key]; delete o[key]; if (v) func(v) },
	// Usage: bool_int('asd') => 1, bool_int('') => 0, bool_int(false) => 0
	bool_int = v => Boolean(v)+0

let debounce_enabled = true
let debounce = (delay_ms, mode, func) => {
	// Modes:
	//  last - delay after last call; usage: not called on fast typing until delay passes
	//  now - now + delay; usage: rate-limiting calls, where first one works, next one delayed
	//  first - delay after first call; usage: same as "now" but with first call delayed as well
	let timeout, timeout_calls
	return (...args) => {
		if (!debounce_enabled) return func(...args)
		if (mode === 'now' && !timeout) func(...args)
		if (timeout) {
			timeout_calls++
			if (mode === 'last') { clearTimeout(timeout); timeout = null } }
		else timeout_calls = 0
		if (!timeout) timeout = setTimeout(() => {
			timeout = null; if (!(mode === 'now' && !timeout_calls)) func(...args) }, delay_ms) } }

let state_tracker = (state={}) => {
	let cbs = d3.dispatch('update')
	let tracker = (k, v, v_def) => {
		// Returns (v=null) and/or sets state value
		//  v_def only gets set/returned if there's no such key already
		if (k === undefined) return state
		if (v !== undefined) {
			let updated = false
			if (k in state) {
				if (v !== null) {
					updated = state[k] !== v
					state[k] = v }
			} else {
				updated = v !== null
				state[k] = v !== null ? v : v_def }
			if (updated) cbs.call('update', null, k, state[k], state) }
		return k in state ? state[k] : null }
	tracker.on = (t, cb) => {
		let ret = cbs.on(`update.${t}`, cb)
		return !cb ? ret : tracker }
	tracker.prefix = (pre, cb) => {
		if (cb) tracker.on( pre,
			(k, v, vs) => k.startsWith(pre) && cb(k.slice(pre.length), v, vs) )
		return (k, v, v_def) => tracker(pre + k, v, v_def) }
	return tracker
}

let url_enc = v => {
	if (typeof v === 'boolean') v = v ? '!t' : '!f'
	else if (typeof v === 'number')
		v = Number.isInteger(v) ? `!n{v}` : `!f{v.toFixed(2)}`
	else if (v.length && v[0] === '!')
		throw `ERROR: url_enc value cannot start with excl-mark - "${v}"`
	return v }
let url_dec = v => {
	if (v.length >= 2 && v[0] === '!') {
		v = v.slice(1)
		if ('ft'.split('').includes(v)) v = Boolean('ft'.split('').indexOf(v))
		else if (v.length && 'nf'.split('').includes(v[0]))
			v = (v[0] === 'n' ? Number.parseInt : Number.parseFloat)(v.slice(1))
		else v = null }
	return v }


// Data form

let
	state_defaults = {},
	state = state_tracker(
		[...(new window.URL(window.location.href)).searchParams.entries()]
			.reduce((o, [k,v]) => { o[k] = url_dec(v); return o }, {}) )
		.on('url', (k, v) => {
			let url = new window.URL(window.location.href)
			if (v === state_defaults[k]) url.searchParams.delete(k)
			else url.searchParams.set(k, url_enc(v))
			window.history.replaceState(history.state, document.title, url.href) })

let
	items = data,
	items_info = d3.set( (state('i') || '').split('.').filter(d => d.length > 0)
		.map(d => (d.startsWith('str_') ? d : `str_${d}`).toUpperCase()) ),
	items_battle = Object.values(data).filter(e => e.battleType)

let stats = new Map([ ['strength', 35], ['melee', 70],
		['throwing', 40], ['TUs', 65], ['bravery', 30], ['reactions', 40] ]),
	info_fields = [ 'weight', 'weapon', 'type',
		'damage', 'accuracy',  'dpu', 'costs', 'specials' ],
	// dmg_types are partly hardcoded in RuleItem.h (enum ItemDamageType)
	// Some are renamed in localization files, e.g. 0=NONE -> CHARM
	info_dmg_types = {
		0: 'charm', 1: 'piercing', 2: 'burn', 3: 'concussive', 4: 'laser', 5: 'plasma', 6: 'daze', 7: 'cutting', 8: 'chem', 9: 'choke',
		10: 'anti-e511', 11: 'bio', 12: 'electric', 13: 'emp', 14: 'warp', 15: 'mind', 16: 'heat', 17: 'cold' },
	// From enum in RuleDamageType.h, described under DRT_ stuff
	info_random_types = {
		0: 'vanilla', 1: '1d(x0-x2)', 2: '1d(x.5-x1.5)', 3: 'flat(x1)', 4: 'fire(5-10)', 5: 'no-dmg(x0)', 6: '2d(x0-x1)' }


let item_stats = d => {
	let attrs = obj_tuples( map_entries(stats),
		d => [d.key, state_attrs(d.key) || stats.get(d.key)] )

	let info = {
		weapon: {text: d.name, title: `id: ${d.type.toLowerCase()}`}
	}

	// Get keys used for accuracy/tu/costs of the item in most interesting mode
	// Most items have throw and such, but that's least interesting unless it's a javelin
	let k, k_type, k_acc, k_tu, k_cost
	for (k of ['Melee', 'Auto', 'Snap', 'Aimed', 'Throw']) {
		[k_acc, k_tu, k_cost] = [`accuracy${k}`, `tu${k}`, `cost${k}`]
		if (k_acc in d) break
	}
	k_type = k.toLowerCase()

	// Weight - can be sometimes weird too
	GetWeight: {
		let weight, weight_raw, weight_title
		if ('weight' in d) {
			weight = weight_raw = d.weight
			if (weight < 0) weight_title = '- Negative value, might have factors not checked here.'
		} else {
			[weight, weight_raw] = ['---', 0]
			weight_title = '- Missing value, might be calculated in some way that is not implemented here.'
		}
		info.weight = {text: weight, title: weight_title, value: weight_raw}
	}

	// Attack/use costs
	let cost_tu // also used for dpu field
	CalcCosts: {
		let cost_str = '', cost_title = []
		let cost_tu_flat = d.flatRate
		if (d.flatMelee && d.flatMelee.time && k_type == 'melee')
			cost_tu_flat = true // flat gunbutt costs, while firing is %-based
		if (k_tu in d) cost_tu = d[k_tu] // old-style tu-only value
		else if (k_cost in d) { // new-style multi-attribute costs
			k = obj_clone(d[k_cost])
			cost_tu = obj_pop(k, 'time')
			obj_pop_run(k, 'energy', d => { cost_str += ` ${d}E` })
			obj_pop_run(k, 'morale', d => {
				cost_str += d > 0 ? ` ${d}M` : ` ${-d}M-boost`
				cost_title.push( d > 0 ?
					'- Damages own (user\'s) morale!'
					: '- Gives Morale boost to user.' ) })
			obj_pop_run(k, 'stun', d => {
				cost_str += d > 0 ? ` ${d}STN` : ` ${-d}STN-heal`
				cost_title.push( d > 0 ?
					'- Inflicts stun (STN) damage to user!'
					: '- Heals stun (STN) damage on user.' ) })
			if (Object.keys(k).length > 0) {
				cost_str += ' others'
				cost_title.push(`- Other costs: ${JSON.stringify(k)}`) }
		}
		k = cost_tu
		if (!cost_tu_flat) cost_tu *= attrs.TUs / 100
		k = `${d3.format('d')(cost_tu)} TU` + (cost_tu_flat ? '' : ` [${k}%]`)
		if (cost_tu_flat) cost_title.push('- Flat TU cost (non-flat shows % in brackets).')
		cost_str = k + (cost_str ? ' + ' + cost_str : '')
		cost_title = !cost_title.length ? null : cost_title.join('\n')
		info.costs = {text: cost_str, title: cost_title, value: cost_tu}
	}

	// Type - 1H/2H + attack/damage types
	CalcDamageType: {
		let type_str = '', type_title = []
		let [t2h, t1h_allow] = [bool_int(d.twoHanded), -bool_int(d.oneHandedPenalty)]
		type_str += t2h ? (t1h_allow ? `2H [-${d.oneHandedPenalty}%]` : '2H-only') : '1H'
		let tdt = d.damageType
		if (!tdt) { k = '???'; type_title.push('- No damage type info.') }
		else if (tdt in info_dmg_types) k = info_dmg_types[tdt]
		else { type_title.push(`- Unrecognized damage type id = ${tdt}.`); k = `DT#${tdt}` }
		type_str += `, ${k_type}, ${k}`
		type_title = !type_title.length ? null : type_title.join('\n')
		info.type = {text: type_str, title: type_title, value: [t2h, t1h_allow, tdt]}
	}

	// Accuracy
	let acc // used in dpu calculation
	CalcAccuracy: {
		let acc_str = '', acc_str_warn = '', acc_title = []
		acc = acc_base = d[k_acc] || -1
		if (acc <= 0) break CalcAccuracy
		acc_title.push(`- Base: ${acc}`)

		// Calculate bonus_sum from meleeMultiplier / accuracyMultiplier factors
		let factors, factor_sum = 0
		for (k of ['melee', 'accuracy']) { // assuming they're mutually exclusive
			k = d[`${k}Multiplier`]
			if (!k || Object.keys(k).length <= 0) continue
			if (factors) {
				if (k_type != 'melee') {
					acc_str_warn = '[!!!] '
					acc_title.push( '- Found both meleeMultiplier'+
						' and accuracyMultiplier, assuming melee.' ) }
				continue }
			factors = k }
		factors = obj_clone(factors)
		for (let [attr, attr_value] of Object.entries(attrs)) {
			let attr_factor = obj_pop(factors, attr) || 0
			if (!attr_factor) continue
			if (!Array.isArray(attr_factor)) attr_factor = [attr_factor]
			for (k=0; k<attr_factor.length; k++) {
				if (attr_factor[k] == 0) continue
				let factor = (attr_value * attr_factor[k]) ** (k+1)
				let factor_str = `${attr_value} * ${attr_factor[k]}`
				if (k > 0) factor_str = `(${factor_str})^${k+1}`
				acc_title.push(`- Factor [${attr}]: ${factor_str} = ${d3.format('.1f')(factor)}`)
				factor_sum += factor  } }
		let factor_flat = (obj_pop(factors, 'flatHundred') || 0) * 100
		if (factor_flat) acc_title.push(`- Factor [flat value]: ${factor_flat}`)
		k = factor_flat ? `(${factor_flat} + ${factor_sum})` : `${factor_sum}`
		acc = acc * (factor_flat + factor_sum) / 100
		acc_title.push(`- Formula: ${acc_base} * ${k} / 100 = ${acc}`)
		for (k of Object.keys(factors)) {
			if (factors[k] == 0) delete factors[k] }
		if (Object.keys(factors).length > 0) {
			acc_str_warn = '[!!!] '
			acc_title.push(`- Factors not applied: ${JSON.stringify(factors)}`) }
		acc_str = acc_str_warn + `${d3.format('.0f')(acc)}%`
		acc_title = !acc_title.length ? null : acc_title.join('\n')
		info.accuracy = {text: acc_str, title: acc_title, value: acc}
	}

	// Damage
	let dmg // used in dpu calculation
	CalcDamage: {
		let dmg_str = '', dmg_str_warn = '', dmg_title = []
		dmg = d['power'] || -1
		if (dmg <= 0) break CalcDamage
		dmg_title.push(`- Base: ${dmg}`)
		let factors = obj_clone(d.damageBonus || {}), factor_sum = 0
		for (let [attr, attr_value] of Object.entries(attrs)) {
			let attr_factor = obj_pop(factors, attr) || 0
			if (!attr_factor) continue
			if (!Array.isArray(attr_factor)) attr_factor = [attr_factor]
			for (k=0; k<attr_factor.length; k++) {
				if (attr_factor[k] == 0) continue
				let factor = (attr_value * attr_factor[k]) ** (k+1)
				let factor_str = `${attr_value} * ${attr_factor[k]}`
				if (k > 0) factor_str = `(${factor_str})^${k+1}`
				dmg_title.push(`- Factor [${attr}]: ${factor_str} = ${d3.format('.1f')(factor)}`)
				factor_sum += factor  } }
		k = dmg; dmg += factor_sum
		dmg_title.push(`- Formula: ${k} + ${factor_sum} = ${dmg}`)
		dmg_title = !dmg_title.length ? null : dmg_title.join('\n')
		info.damage = {text: `${dmg}`, title: dmg_title, value: dmg}
	}

	// DPU (normalized damage values)
	CalcDPU: {
		if (!(dmg >= 0 && acc >= 0 && cost_tu >= 0)) break CalcDPU
		let dpu = dmg * (acc / 100) / cost_tu
		info.dpu = { text: `${d3.format('.1f')(dpu)}`, value: dpu,
			title: `- Formula: ${dmg} * (${acc} / 100) / ${cost_tu} = ${d3.format('.2f')(dpu)}\n`+
				'- Note: with probabilities over multiple attempts, accuracy is *not* a linear factor.' }
	}

	// Special stuff like damage to stats and armor effectiveness, there's a lot of these
	CalcSpecials: {
		let ext = [], ext_title = []
		let da = obj_clone(d.meleeAlter || d.damageAlter || {})
		obj_pop_run(da, 'ArmorEffectiveness', d => {
			if (d == 1) return
			ext.push(`kArmor=${d}`)
			ext_title.push( '- kArmor is "Enemy Armor Effectiveness" (lower = better),\n'+
				'  so e.g. kArmor=2 means 2x damage thresholds/resistance vs weapon.' )
		})
		obj_pop_run(da, 'ResistType', d => {
			let dt = info_dmg_types[d]
			if (!dt) { dt = 'DT#${d}'; ext_title.push(`- Unrecognized damage type id = ${d}.`) }
			ext.push(`resist=${dt}`)
			ext_title.push(`- Armor resistance "${dt}" (reduction %) is used for calculating damage value.`)
		})
		let k, kx
		for ([k, kx] of [
				['ToHealth', 'toH'], ['ToStun', 'toStn'],
				['ToEnergy', 'toE'], ['ToMorale', 'toM'],
				['ToTime', 'toTU'], ['ToArmorPre', 'toAP'] ]) {
			obj_pop_run(da, k, d => {
				ext.push(`${kx}=${d}`)
				ext_title.push(`- "${kx}" is a "damageAlter.${k}" value, if it helps.`) })
		}
		obj_pop_run(da, 'RandomType', d => {
			k = info_random_types[d]
			if (!k) {
				k = `rnd=DRT#${d}`; ext.push(k)
				ext_title.push(`- ${k} shows raw unrecognized RandomType value.`) }
			else {
				k = `rnd=${k}`; ext.push(k)
				ext_title.push( `- "${k}" is how weapon Power value translates to rnd-ish damage.\n`+
					'  "XdY" is X uniform dice rolls of Y, e.g. 2d(x0-x1) is a more mid-range 0-200%.' ) }
		})
		obj_pop_run(da, 'IgnoreOverKill', d => {
			ext.push(`no-ok`)
			ext_title.push(`- no-ok = IgnoreOverKill, probably for stun damage.`)
		})
		obj_pop_run(da, 'IgnoreDirection', d => {
			ext.push(`unidir`)
			ext_title.push(`- unidir = IgnoreDirection, .`)
		})
		obj_pop(da, 'FixRadius')
		if (Object.keys(da).length > 0) {
			ext.push('+')
			ext_title.push(`- More modifiers: ${JSON.stringify(da)}`)
		}
		if (d.meleeAlter && d.damageAlter) {
			ext.push('++')
			ext_title.push( '- Showing stuff from meleeAlter section,'+
				` separate damageAlter section (for other attack types): ${JSON.stringify(d.damageAlter)}` )
		}
		ext = !ext.length ? null : ext.join(' ')
		ext_title = !ext_title.length ? null : ext_title.join('\n')
		info.specials = {text: ext, title: ext_title}
	}

	return { id: d.type, fields: new Map(info_fields.map(d => {
		let field_info = info[d] || {}
		return [ d, {
			text: field_info.text && `${field_info.text}`,
			title: field_info.title,
			value: field_info.value || field_info.text } ] })) }
}


let refresh = () => {
	d3.select('#info').selectAll('tr')
		.data(items_info.values().map(d => item_stats(items[d])), d => d.id)
		.call(s => s.exit().remove())
		.call(s => s
			.enter().append('tr').merge(s)
			.each((d, n, ns) => {
				let s = d3.select(ns[n])
					.selectAll('td').data(d => map_entries(d.fields), d => d.key)
					.call(s => s.exit().remove())
					.call(s => s
						.enter().append('td').attr('headers', d => `info-th-${d.key}`).merge(s)
						.text(d => d.value.text || '').attr('title', d => d.value.title)) }))
	let box_info = document.getElementById('info'),
		box_weapons = document.getElementById('fields-weapons')
	box_weapons.style.height = `${box_info.offsetHeight}px`
}


let weapon_search = (d, n, ns) => {
	let input = ns[n].value
	state('q', input)
	if (input.length <= 0) return
	let items = items_battle.filter( e => e.name == input ||
		e.name.includes(input) || e.name.toLowerCase().includes(input.toLowerCase()) ||
		e.type == input || e.type.toLowerCase().includes(input.toLowerCase()) )
	d3.select('#input-weapon-select')
		.selectAll('option').data(items, d => d.type)
		.call(s => s.exit().remove())
		.enter().append('option')
			.attr('value', d => d.type).text(d => d.name)
			.attr('selected', d => items_info.has(d.type) || null)
}


let state_attrs = state.prefix('a.')

let form = d3.select('body').append('form')
	.call(s => s
		.append('fieldset').attr('class', 'stats')
		.call(s => s.append('legend').text('stats'))
		.selectAll('input').data(map_entries(stats))
		.enter()
			.append('label').attr('for', d => `input-stats-${d.key}`).text(d => d.key)
			.append('input').on('input', (d, n, ns) => {state_attrs(d.key, ns[n].value); refresh() })
				.call(attrs({
					type: 'number', required: true,
					title: d => `Soldier stat value (${d.key})`,
					min: 0, max: 200, step: 1,value: d => state_attrs(d.key) || d.value,
					id: d => `input-stats-${d.key}`, name: d => d.key })))
	.call(s => s
		.append('fieldset').call(attrs({'class': 'weapons', id: 'fields-weapons'}))
		.call(s => {
			s.append('legend').text('weapons')
			s.append('input').on('input', debounce(300, 'last', weapon_search))
				.call(attrs({ 'class': 'search', type: 'search',
					title: 'Item Search Box - type in any part of item names or IDs here',
					value: state('q'), list: 'input-weapons-datalist',
					id: 'input-weapon-search', name: 'weapon-search' }))
				.call(fire_event('input'))
			s.append('datalist').attr('id', 'input-weapon-datalist')
				.call(s => items_battle.map(e => {
					s.append('option').attr('value', e.type)
					s.append('option').attr('value', e.name) }))
			s.append('select')
				.on('input', (d, n, ns) => {
					d3.select(ns[n]).selectAll('option').each(
						(d, n, ns) => ns[n].selected ?
							items_info.add(d.type): items_info.remove(d.type) )
					state('i', items_info.values().map(d => d.replace(/^STR_/, '')).join('.').toLowerCase())
					refresh() })
				.call(attrs({ 'class': 'list', multiple: true,
					title: 'Select items to display info on here.\n'+
						'Use CTRL/SHIFT keys and mouse-drag to pick multiple ones.',
					id: 'input-weapon-select', name: 'weapon-select' }))}))
	.call(s => s
		.append('table').attr('class', 'info')
		.call(s => s.append('thead').append('tr')
			.selectAll('th').data(info_fields)
			.enter().append('th').text(d => d)
			.call(attrs({id: d => `info-th-${d}`, title: d => `Click to sort table by this field (${d})`}))
			.on( 'click', (d, n, ns) => d3.select('#info').selectAll('tr')
				.sort(sort_by_func(d3.ascending, d2 => d2.fields.get(d).value)) ))
		.call(s => s.append('tbody').attr('id', 'info'))
		.call(s => s.append('tfoot').append('tr')))
	.call(s => s.append('ul').attr('class', 'tips')
		.selectAll('li').data([
			'Use search field at the top of the Weapons box to look for weapons and mark them for comparison.',
			'CTRL/SHIFT + click/drag in Weapons list to pick many, as found + unselected items there are removed from table.',
			'Use (SHIFT+)TAB to jump over stat input fields quickly.',
			'Clicking table headers will sort on that column.',
			'Hovering over table values (e.g. accuracy, costs, damage) will show tooltips with more info/help on each.',
			'"!!!" alongside value usually means some kind of data anomaly and that it can be incorrect.',
			'Implemented in py but not here: stuff with ammo types (e.g. guns, bows - need more UI), more "specials" stuff.' ])
		.enter().append('li').text(d => d))

refresh()

}
</script>
</body>
